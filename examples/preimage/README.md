# BIP-143 Preimage Tools

This directory contains tools and examples for working with Bitcoin BIP-143 transaction preimages.

## Files

### `extract_preimage_bidirectional.js`
**Advanced bidirectional preimage field extractor with optimal ASM generation**

Intelligently extracts any BIP-143 preimage field using the most efficient strategy:
- **LEFT extraction** for early fields (nVersion, hashPrevouts, etc.)
- **RIGHT extraction** for late fields (value, nLocktime, sighashType, etc.)  
- **DYNAMIC extraction** for variable-length scriptCode

#### Features
- âœ… Complete BIP-143 specification compliance
- âœ… Optimal operation count for each field
- âœ… Generates production-ready Bitcoin Script ASM
- âœ… Handles variable scriptCode dynamically
- âœ… Robust error handling and validation
- âœ… Field interpretation (satoshis, version numbers, etc.)

#### Usage
```bash
# Extract any preimage field
node extract_preimage_bidirectional.js <preimage_hex> <field_name>

# Examples
node extract_preimage_bidirectional.js 01000000ab12cd... scriptCode
node extract_preimage_bidirectional.js 01000000ab12cd... value
node extract_preimage_bidirectional.js 01000000ab12cd... sighashType
```

#### Available Fields

**LEFT Fields (fixed offsets from start):**
- `nVersion` (4 bytes) - Transaction version
- `hashPrevouts` (32 bytes) - Hash of all input outpoints  
- `hashSequence` (32 bytes) - Hash of all input sequences
- `outpoint_txid` (32 bytes) - Current input's previous transaction ID
- `outpoint_vout` (4 bytes) - Current input's previous output index
- `scriptLen` (1 byte) - Length of the scriptCode

**DYNAMIC Field (uses internal length):**
- `scriptCode` (variable) - The script being executed

**RIGHT Fields (fixed offsets from end):**
- `value` (8 bytes) - Input amount in satoshis
- `nSequence` (4 bytes) - Current input's sequence number
- `hashOutputs` (32 bytes) - Hash of all outputs
- `nLocktime` (4 bytes) - Transaction lock time
- `sighashType` (4 bytes) - Signature hash type

#### Integration with Covenant Framework

The generated ASM can be used directly in covenant locking scripts:

```javascript
const { CovenantInterface } = require('../../lib/covenant-interface');

// Use bidirectional extraction in covenant
const covenant = new CovenantInterface();
const script = covenant.createAdvancedCovenant({
  type: 'custom',
  rules: {
    // Insert generated ASM for preimage field extraction
    extractValue: `
      # Generated by extract_preimage_bidirectional.js
      OP_SIZE
      52 OP_SUB
      OP_SPLIT
      OP_DROP
      8 OP_SPLIT
      OP_DROP
    `
  }
});
```

#### BIP-143 Structure Reference

```
Total: LEFT(105) + scriptCode(variable) + RIGHT(52) bytes

LEFT ZONE (105 bytes):           DYNAMIC:              RIGHT ZONE (52 bytes):
â”œâ”€ nVersion (4)                  â”œâ”€ scriptCode         â”œâ”€ value (8) 
â”œâ”€ hashPrevouts (32)             â””â”€ (scriptLen bytes)  â”œâ”€ nSequence (4)
â”œâ”€ hashSequence (32)                                   â”œâ”€ hashOutputs (32)
â”œâ”€ outpoint_txid (32)                                  â”œâ”€ nLocktime (4)
â”œâ”€ outpoint_vout (4)                                   â””â”€ sighashType (4)
â””â”€ scriptLen (1)
```

## See Also
- `../../docs/preimage.md` - BIP-143 technical specification
- `../../docs/ADVANCED_COVENANT_DEVELOPMENT.md` - Covenant implementation guide
- `../covenants/` - Complete covenant examples using preimage extraction
- `../../lib/covenant-interface.js` - CovenantPreimage class implementation

### `generate_sighash_examples.js`
**SIGHASH flag preimage generator demonstrating "zero hash" behavior**

Explains why multi-input transactions appear to have "extra zeros" - they're not bugs but required by BIP-143 SIGHASH rules:

#### Features
- âœ… Complete SIGHASH flag support (ALL, NONE, SINGLE, ANYONECANPAY)
- âœ… Demonstrates zero hash field behavior  
- âœ… Educational tool for multi-input transaction analysis
- âœ… Integration with bidirectional extractor

#### Usage
```bash
# Generate SIGHASH examples
node generate_sighash_examples.js [sighash_type]

# Examples showing zero hash behavior
node generate_sighash_examples.js ALL_ANYONECANPAY_FORKID   # Zero hashPrevouts + hashSequence
node generate_sighash_examples.js NONE_FORKID              # Zero hashOutputs
node generate_sighash_examples.js NONE_ANYONECANPAY_FORKID # Zero all hash fields
```

#### SIGHASH Flag Behavior
| SIGHASH Type | hashPrevouts | hashSequence | hashOutputs | Use Case |
|--------------|-------------|-------------|-------------|-----------|
| ALL_FORKID | Normal | Normal | Normal | Standard signing |
| NONE_FORKID | Normal | Normal | **Zero** | Blank check |
| SINGLE_FORKID | Normal | Normal | **Zero** | One-to-one |
| ALL_ANYONECANPAY_FORKID | **Zero** | **Zero** | Normal | Crowdfunding |
| NONE_ANYONECANPAY_FORKID | **Zero** | **Zero** | **Zero** | Maximum flexibility |

### `test_varint_extraction.js`
**Comprehensive CompactSize varint test suite**

Validates proper parsing of 1-3 byte CompactSize varints in real-world scenarios:
- 1-byte encoding: 0-252 bytes (most common)
- 3-byte encoding: 253-65535 bytes (large scripts)
- 5-byte encoding: 65536+ bytes (huge scripts)

## ðŸ§  **Understanding the "Extra Zero" Mystery**

### The Problem
Developers often see patterns like this in BSV preimages and think it's a bug:
```
...1976a914000000000000...
```

### The Reality 
These zeros are **intentional** and required by Bitcoin's BIP-143 specification:

1. **CompactSize Varint Encoding**
   - Scripts â‰¥253 bytes use 3-byte encoding: `0xFD + 2-byte length`
   - This adds "extra bytes" that look like zeros to developers expecting 1-byte

2. **SIGHASH Flag Behavior**  
   - `ANYONECANPAY`: Zeros out `hashPrevouts` and `hashSequence` (64 zero bytes)
   - `NONE`: Zeros out `hashOutputs` (32 zero bytes)
   - `SINGLE`: Zeros out `hashOutputs` for unmatched outputs

3. **Multi-Input Concatenation Issues**
   - Wrong byte boundary slicing between inputs
   - Reusing preimage buffers without proper re-serialization

### The Solution
Our bidirectional extractor handles all these cases:
- âœ… **Auto-detects** CompactSize varint size (1-3 bytes)
- âœ… **Warns about** zero hashes with SIGHASH flag context
- âœ… **Validates** preimage structure against BIP-143
- âœ… **Generates** optimal ASM regardless of complexity

## Performance Notes

The enhanced bidirectional strategy minimizes script operations:
- **LEFT fields**: Direct offset splitting (2-3 operations)
- **RIGHT fields**: Size-based splitting (3-4 operations)  
- **scriptCode**: Dynamic extraction using CompactSize varint (3-4 operations)
- **Zero hash detection**: Automatic with contextual warnings

This is significantly more efficient than linear parsing and handles all BIP-143 edge cases that break traditional parsers.